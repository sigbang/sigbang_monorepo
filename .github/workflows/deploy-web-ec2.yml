name: Deploy user front (EC2 + ALB)

on:
  push:
    branches: [ main, master ]
    paths:
      - "sigbang_user_front/**"
      - ".github/workflows/deploy-web-ec2.yml"
      - "sigbang_infra/**"
  # NOTE:
  # - push: 브랜치에 머지되면 Docker 이미지만 빌드/푸시합니다 (자동).
  # - workflow_dispatch: 사람이 수동으로 실행했을 때만 프로덕션 배포가 진행됩니다.
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.image.outputs.image }}
    defaults:
      run:
        working-directory: sigbang_user_front
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: npm
      - run: npm install --no-audit --no-fund
      - name: Build Docker image
        env:
          WEB_GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
        run: |
          docker build \
            --build-arg GOOGLE_CLIENT_ID=$WEB_GOOGLE_CLIENT_ID \
            --build-arg NEXT_PUBLIC_GOOGLE_CLIENT_ID=$WEB_GOOGLE_CLIENT_ID \
            -t ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }} .
      - name: Login to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Push Docker image
        run: |
          docker tag ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/sigbang_user_front:latest
          docker push ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }}
          docker push ghcr.io/${{ github.repository_owner }}/sigbang_user_front:latest
      - name: Set image output
        id: image
        run: echo "image=ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }}" >> $GITHUB_OUTPUT

  deploy-web-ssm:
    needs: build-and-push
    # 프로덕션 배포는 수동(workflow_dispatch)으로 실행될 때만 수행되도록 제한
    if: github.event_name == 'workflow_dispatch'
    # GitHub UI에서 production 환경에 Required reviewers 를 걸어두면
    # 배포 전에 사람 승인 단계를 추가할 수 있습니다.
    environment: production
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Resolve image to deploy
        id: resolve
        run: |
          IMAGE_OUT="${{ needs.build-and-push.outputs.image }}"
          if [ -z "$IMAGE_OUT" ]; then
            IMAGE_OUT="ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }}"
          fi
          echo "image=$IMAGE_OUT" >> $GITHUB_OUTPUT
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2
      - name: Deploy Web via SSM RunCommand (no SSH)
        env:
          IMAGE: ${{ steps.resolve.outputs.image }}
          AWS_REGION: ap-northeast-2
          # ASG Name tag value for Web instances (from Terraform): var.web_project_name => "sigbang-web"
          TARGET_NAME_TAG: sigbang-web
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          CONTAINER_NAME: sigbang-web
          EXPOSE_PORT: "3000"
        run: |
          echo "Resolving target instance by tag Name=${TARGET_NAME_TAG}"
          IID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${TARGET_NAME_TAG}" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text --region "$AWS_REGION")
          if [ -z "$IID" ]; then
            echo "No running instance found with Name=${TARGET_NAME_TAG}"
            exit 1
          fi
          echo "Target instance: $IID"

          cat >ssm-deploy-web.json <<EOF
          {
            "DocumentName": "AWS-RunShellScript",
            "Comment": "Deploy sigbang-web container via SSM",
            "InstanceIds": ["$IID"],
            "Parameters": {
            "commands": [
                "touch /tmp/ssm-deploy-web-test && echo 'hello-from-ssm' > /tmp/ssm-deploy-web-test.txt",
                "set -eu",
                "IMAGE='${IMAGE}'",
                "EXPOSE_PORT=${EXPOSE_PORT}",
                "CONTAINER_NAME='${CONTAINER_NAME}'",
                "echo '[deploy-web-ssm] Starting deploy of $IMAGE' | sudo tee -a /var/log/userdata-web.log >/dev/null",
                "if echo \\"$IMAGE\\" | grep -q '^ghcr.io/' && [ -n '${GHCR_USERNAME}' ] && [ -n '${GHCR_TOKEN}' ]; then echo '${GHCR_TOKEN}' | sudo docker login ghcr.io -u '${GHCR_USERNAME}' --password-stdin || true; fi",
                "sudo docker system prune -af || true",
                "sudo docker pull \\"$IMAGE\\"",
                "sudo docker ps --filter \\"publish=$EXPOSE_PORT\\" -q | xargs -r sudo docker rm -f || true",
                "sudo docker rm -f \\"$CONTAINER_NAME\\" || true",
                "[ -f /home/ubuntu/web.env ] && ENV_FILE_ARG='--env-file /home/ubuntu/web.env' || ENV_FILE_ARG=''",
                "sudo docker run --pull=always -d --name \\"$CONTAINER_NAME\\" --restart=always $ENV_FILE_ARG -p $EXPOSE_PORT:3000 \\"$IMAGE\\"",
                "sleep 3",
                "echo '[deploy-web-ssm] Started $CONTAINER_NAME with $IMAGE' | sudo tee -a /var/log/userdata-web.log >/dev/null",
                "curl -fsS http://localhost:$EXPOSE_PORT/robots.txt >/dev/null",
                "sudo docker ps -a | sed -n '1p;/$CONTAINER_NAME/p'",
                "sudo docker inspect -f 'Image={{.Config.Image}} State={{.State.Status}}' $CONTAINER_NAME"
              ]
            }
          }
          EOF

          CMD_ID=$(aws ssm send-command \
            --cli-input-json file://ssm-deploy-web.json \
            --region "$AWS_REGION" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM command sent. CommandId=$CMD_ID"




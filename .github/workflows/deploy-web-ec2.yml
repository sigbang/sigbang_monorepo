name: Deploy user front (EC2 + ALB)

on:
  push:
    branches: [ main, master ]
    paths:
      - "sigbang_user_front/**"
      - ".github/workflows/deploy-web-ec2.yml"
      - "sigbang_infra/**"
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.image.outputs.image }}
    defaults:
      run:
        working-directory: sigbang_user_front
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: npm
      - run: npm install --no-audit --no-fund
      - name: Build Docker image
        run: docker build -t ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }} .
      - name: Login to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Push Docker image
        run: |
          docker tag ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/sigbang_user_front:latest
          docker push ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }}
          docker push ghcr.io/${{ github.repository_owner }}/sigbang_user_front:latest
      - name: Set image output
        id: image
        run: echo "image=ghcr.io/${{ github.repository_owner }}/sigbang_user_front:${{ github.sha }}" >> $GITHUB_OUTPUT

  deploy-web-ssm:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2
      - name: Deploy Web via SSM (restart containers)
        env:
          IMAGE: ${{ needs.build-and-push.outputs.image }}
          AWS_REGION: ap-northeast-2
          # ASG Name tag value for Web instances (from Terraform): var.web_project_name => "sigbang-web"
          TARGET_NAME_TAG: sigbang-web
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          cat > params.json <<JSON
          {
            "commands": [
              "set -euo pipefail",
              "IMAGE='${IMAGE}'",
              "ENV_FILE='/home/ubuntu/web.env'",
              "if echo \"$IMAGE\" | grep -q '^ghcr.io/'; then if [ -n \"${GHCR_USERNAME:-}\" ] && [ -n \"${GHCR_TOKEN:-}\" ]; then echo \"$GHCR_TOKEN\" | docker login ghcr.io -u \"$GHCR_USERNAME\" --password-stdin || true; fi; fi",
              "docker pull \"$IMAGE\"",
              "docker rm -f sigbang-web || true",
              "docker run -d --name sigbang-web --restart=always --env-file \"$ENV_FILE\" -p 3000:3000 \"$IMAGE\"",
              "sleep 3",
              "curl -fsS http://localhost:3000/robots.txt || exit 1"
            ]
          }
          JSON
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Web ${IMAGE}" \
            --targets "Key=tag:Name,Values=${TARGET_NAME_TAG}" \
            --parameters file://params.json \
            --timeout-seconds 600 \
            --max-concurrency "100%" \
            --max-errors "0" \
            --region "$AWS_REGION" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM CommandId: $CMD_ID"

          # Wait for all command invocations to complete and fail fast on errors
          ATTEMPTS=0
          MAX_ATTEMPTS=120   # up to ~10 minutes (120 * 5s)
          while true; do
            STATUSES=$(aws ssm list-command-invocations \
              --command-id "$CMD_ID" \
              --details \
              --query "CommandInvocations[].Status" \
              --output text \
              --region "$AWS_REGION" || true)

            # When there are multiple instances, statuses are space-separated
            if echo "$STATUSES" | grep -Eq "(Failed|Cancelled|TimedOut)"; then
              echo "One or more SSM command invocations failed: $STATUSES"
              exit 1
            fi

            # If there are no pending statuses, we're done
            if ! echo "$STATUSES" | grep -Eq "(Pending|InProgress|Delayed)"; then
              echo "All SSM command invocations completed successfully: $STATUSES"
              break
            fi

            ATTEMPTS=$((ATTEMPTS+1))
            if [ "$ATTEMPTS" -ge "$MAX_ATTEMPTS" ]; then
              echo "Timed out waiting for SSM command to complete"
              exit 1
            fi
            sleep 5
          done


